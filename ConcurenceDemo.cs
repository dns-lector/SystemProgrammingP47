using System;
using System.Collections.Generic;
using System.Text;

namespace SystemProgrammingP47
{
    internal class ConcurenceDemo
    {
        public void Run()
        {
            Console.WriteLine("ConcurenceDemo start");
            sum = 100.0;
            cnt = 12;
            for(int i = 0; i < 12; i += 1)
            {
                new Thread(LoadPercent).Start(i + 1);
            }
        }

        private double sum;
        private readonly Object sumLocker = new();   // об'єкт, створений заради критичної секції
        private int cnt;

        private void LoadPercent(Object? arg)  // arg - int = номер місяця 
        {
            if (arg is int month)
            {                      
                Console.WriteLine($"Load start month {month}");
                Thread.Sleep(1000);   // імітація тривалості запиту
                double percent = month;
                double k = 1.0 + percent / 100.0;
                double res;
                bool isLast;
                lock (sumLocker)  
                {                 
                    res = sum;
                    res = res * k;
                    sum = res;
                    cnt = cnt - 1;
                    isLast = cnt == 0;  // локально - фіксуємо стан на момент синхронізованої операції
                // Console.WriteLine($"Load finish month {month}, sum = {sum}");   // усі звернення до спільного ресурсу синхронізуються
                }
                Console.WriteLine($"Load finish month {month}, sum = {res}");   // локальна змінна (res) дозволяє винести код з блока
            
                if(isLast)   // (cnt == 0) - неправильно, глобальна змінна напевно змінена іншими потоками
                {
                    Console.WriteLine($"Total: {res}");
                }
            }
            else
            {
                Console.WriteLine("arg must be int, not " + (arg?.GetType().Name ?? "NULL"));
            }
        }


        private void LoadPercentWrong(Object? arg)  // arg - int = номер місяця 
        {
            if(arg is int month)
            {                     // Блок синхронізації - набір команд, який не допускає одночасного виконання
                lock (sumLocker)  // lock перевіряє критичну секцію sumLocker: якщо вона відкрита, то закриває і виконує блок
                {                 // якщо закрита, то ставить потік на паузу (блокує) до отримання сигналу про відкриття sumLocker
                    double res = sum;                                  // Погана практика - вміщувати весь код методу у
                    Console.WriteLine($"Load start month {month}");    // синхроблок. Це не дозволяє паралельні процеси, окрім
                    Thread.Sleep(1000);                                // тих, що поза блоком
                    double percent = month;                            // Слід прагнути до мінімізації вмісту цього блоку, 
                    double k = 1.0 + percent / 100.0;                  // у т.ч. введенням локальних змінних, якщо слід
                    res = res * k;                                     // утворювати копії глобальних
                    sum = res;                                         // 
                }                 // кінець блоку відкриває критичну секцію sumLocker, що подає сигнал на роботу іншим блокам

                Console.WriteLine($"Load finish month {month}, sum = {sum}");
            }
            else
            {
                Console.WriteLine("arg must be int, not " + (arg?.GetType().Name ?? "NULL"));
            }
        }
    }
}
/* Конкуренція потоків. Синхронізація
 * - потокові функції/методи не повертають результати
 * - потоки корисні для поділу завдання на фрагменти, що можуть виконуватись одночасно
 * == для того щоб результати роботи потоків поєднувались необхідно 
 *    створювати спільні ресурси - змінні/поля, які доступні кожному потоку.
 * - при доступі до спільного ресурсу можливі одночасні звернення 
 *   з різних потоків. Така ситуація називається конкуренцією
 *   
 * Головна проблема - розділені у часі операції читання та запису змінних
 *       100        100               110           120
 * res = sum  ....................... sum = res
 *            res = sum ............................sum = res
 *            
 * Синхронізація - утворення блоків коду, які не можуть працювати одночасно.
 * Система надає спеціальні "сигнальні" об'єкти, які вирішують задачу синхронізації:
 * - критична секція (синхронізує потоки в межах процесу)
 * - мьютекс (синхронізує між процесами)
 * - семафор (дозволяє одночасну роботу певної кількості потоків)
 * У С# кожен об'єкт референсного типу має у своєму складі критичну секцію,
 *  тобто може бути використаний для задач синхронізації
 * 
 *   
 * Приклад: розрахунок річної інфляції
 * НБУ публікує відкриті дані - коефіцієнт інфляції за кожен місяць.
 * Задача: розрахувати річний коефіцієнт, запитавши 12 місячних значень.
 * -----------
 * Аналіз на можливість паралельності:
 * чи має значення порядок додавання коефіцієнтів?
 * (100 + 10%) + 20% =?= (100 + 20%) + 10%
 * (100 * 1.10) * 1.20 == (100 * 1.20) * 1.10  -- порядок не грає ролі, якщо цікавить
 * тільки кінцевий результат (проміжні можуть бути неправильними)
 * 
 */
/* Д.З. Користувач вводить число (наприклад, 10)
 * програма запускає відповідну кількість потоків, кожен з яких
 * додає до спільного ресурсу-рядка (string) літеру з відповідним
 * порядком: (10 перших - це abcdefghij)
 * У результаті через конкуренцію порядок літер має виглядати
 * випадковим.
 * Також реалізувати виведення проміжних результатів кожного потоку.
 * Очікуваний вигляд консолі:
 * Enter num: 10
 * Processing letter 5 (e): ce
 * Processing letter 1 (a): cea
 * Processing letter 3 (c): c
 * ....
 * Result: ceaijhbafg
 */